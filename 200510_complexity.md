# 200510 시간복잡도와 공간복잡도 (1)

우선, 며칠동안 쉰 나에게 박수를!

다시 공부할 체력과 마음을 가지게 되었으므로, 오늘은 그동안 미루고 미루고 온 시간복잡도와 공간복잡도의 개념을 공부하고 간단한 예제를 보려고 한다.



## 알고리즘의 평가 - 시간복잡도와 공간복잡도

문제 해결 과정인 알고리즘을 평가하는 방법에는 두가지가 있다.

- 수행 시간에 해당하는 시간복잡도(Time Complexity)

- 메모리 사용량에 해당하는 공간복잡도(Space Complexity)

  

실질적으로는 시간복잡도와 공간복잡도를 정확하게 구분할 수 없기 때문에, 점근적 표기법을 사용한다.



#### Big-O Notation

Big-O 표기법은 알고리즘의 효율성의 상한선을 기준으로 표기한다. 상한선의 값이 클 수록 비효율적임을 의미한다.

###### 수학적 정의

모든 n>=n_0>0에 대하여 0<=f(n)<=k*g(n)인 양의 상수 k와 n_0이 존재하면, f(n) = O(g(n))이다.



즉, 충분히 큰 데이터 개수가 주어질 때, 실행 시간이 최악이어도 점근 상한선인 k*g(n)을 넘길 수 없다는 것을 의미한다.



###### Big-O 표기법의 특징

* 입력값이 충분히 크기 때문에, 가장 영향력이 큰 항 이외에 영향력이 없는 항들(상수항 등)은 무시한다.

* 자주 쓰는 함수들의 시간복잡도 성능을 비교하면 다음과 같다.
  O(1) < O(log n) < O(n) < O(nlogn) < O(n^2) < O(2^n)
  즉, 상수함수 < 로그함수 < 선형함수 < 다항함수 < 지수함수

  이에 대한 자세한 내용은 하단애서 정리하고자 한다.

  

## 시간복잡도

#### 시간복잡도의 종류

- 1 : 입력 자료의 수에 관계없이 일정한 실행 시간을 가지는 알고리즘
- log N : 커다란 문제를 일정한 크기를 갖는 작은 문제로 쪼갤때 나타내는 유형
  ex) 이진탐색
- N : 입력 자료의 수에 따라 선형적으로 실행 시간이 걸리는 경우
  입력 자료 각각에 일정 정도의 동일한 처리를 할 때 나타난다.
  ex) for문
- NlogN : 커다란 문제를 쪼갠 후에, 독립적으로 해결 후 다시 하나로 모으는 경우
- N^2 : 이중루프 내에서 입력자료를 처리하는 경우
- 2^N : 입력 시간이 끔찍하게 늘어날 것이다.



```python
# case 1
sum = n * n  # 대입 1회, 곱셈 1회로 전체 연산 2회
# case 2
sum = 0
for i in range(n):  # 대입 n+1회, 덧셈 n번으로 전체 2n+1번
    sum += n
# case 3
sum = 0
for i in range(n):
    for j in range(n): # 대입 n^2+1번, 덧셈 n^2번으로 전체 2n^2+2n+1
        sum += 1
```



## 공간복잡도

공간복잡도란, 프로그램을 실행시킨 후 완료하는데 필요로 하는 자원 공간의 양을 의미한다.

###### 공식

총 공간요구 = 고정 공간 요구 + 가변 공간 요구 (S(P) = c + S_p(n))

- 고정공간 : 입출력의 횟수, 크기와 관계없는 고정 공간(코드 저장공간, 상수, 단순 변수)
- 가변공간 : 해결하려는 문제의 특성 인스턴스에 의존하는 크기를 가진 구조화 변수들을 위해 필요로하는 공간, 함수가 순환 호출을 할 경우 요구되는 추가 공간 등 동적으로 필요한 공간



```python
# case 1
def factorial(num):
    if num>1:
        return num * factorial(num-1)
    else:
        return 1
    # num이 1이 될 때까지 재귀적으로 호출, 공간복잡도 O(n)

# case 2
def factorial2(num):
    fac = 1
    for i in range(1, n+1):
        fac = fac * i
    return fac
# num값과 상관없이 num, i, fac만 저장, 공간복잡도 O(1)
```



## Remarks

시간복잡도와 공간복잡도의 경우 반비례적인 경향이 강하기 때문에 일반적으로 알고리즘의 척도는 시간복잡도를 위주로 판단한다. 시간복잡도가 괜찮다면 공간복잡도는 어느정도는 이해해 줄 수 있다.