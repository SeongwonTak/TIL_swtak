# 200503_Knapsack 알고리즘

이상할 정도로 잘 길이 안보여서 직접 찾아보고 공부해 본 문제를 정리해보고자 한다.

먼저 문제는 다음과 같다.

https://www.acmicpc.net/problem/12865



## 문제 개요 및 시도

문제를 간단히 요구하면, 다양한 물건들이 있는데 이 물건들에는 무게와 가치가 있다.  어떤 사람이 이 중 몇개의 물건을 골라 가방에 담아 가려고 하는데 이 사람이 들고 갈 수 있는 무게에는 (당연히) 한계가 있다. 어떤 물건을 골라야 들고 갈 수 있으면서 가치의 합이 가장 커질지를 물어보는 문제이다.



처음에는, 물품의 수 조건을 보지 않아서, 그냥 모든 경우를 더 더하면 되지 않을까? 라는 생각에 DFS를 적용하였다. 그 코드는 다음과 같다.

```python
# 평범한 배낭
# DFS버전
from _collections import deque

items, weight_lim = map(int, input().split())
weight = [0] * items
valued = [0] * items
for i in range(0, items):
    weight[i], valued[i] = map(int, input().split())
item_visited = [False] * items
result = deque()
max_valued = 0

def dfs(depth, L):
    global max_valued

    if depth == items:
        return

    for i in range(L, items):
        item_visited[i] = True
        L = i + 1
        result.append(i)

        on_loading = 0
        feel_valued = 0
        for k in range(0, len(result)):
            on_loading += weight[result[k]]

        if on_loading <= weight_lim:
            for j in range(0, len(result)):
                feel_valued += valued[result[j]]
            if feel_valued > max_valued:
                max_valued = feel_valued
            dfs(depth + 1, L)

        result.pop()
        item_visited[i] = False

dfs(0, 0)
print(max_valued)
```

문제는 이렇게 하면 한 가방이 30개 정도 가면... 답이 없어진다. 2^30 ... 가방이 100개면? ~~우린 아마 안될거야. 아 이건 들어가면 큰일나죠~~

그렇다고 가장 무거운거부터 차례대로 넣자니 조금 곤란해보인다.

따라서 사용할 수 있는 방법은 **DP**이다.

DP를 할 때, (개인적으로(?)) **가장 중요한 것은 무엇을 저정할 것인가, 어떤 점화식을 쓸 것인가 이다.**

**이 문제에서 제일 난감한 점은 <u>최초로 입력된 물건이나 가장 무거운 물건이 최종 가방 안에 들어온다는 보장 자체가 없어서</u> 초항을 쉽게 잡을수조차 없다는 것이다.**

부끄럽지만, 이 부분에서 어떻게 점화식을 세워야할지 접근이 잘 되지 않았다. 따라서 하단의 글을 참조하여 그 방법과 내가 직접 따로 쓴 코드를 첨부하려고 한다. 주석을 상세히 달아 어떤 역할을 하는 라인인지도 첨부.



하단의 내용들은 다음을 참조하여 작성하였다.

https://www.geeksforgeeks.org/python-program-for-dynamic-programming-set-10-0-1-knapsack-problem/

https://suri78.tistory.com/2

## DP 풀이

#### 1단계. 관찰

점화식을 세워야 1차원 리스트인지, 2차원 리스트인지... 뭘 어떻게 해야할지 알 수 있을 것이다. 따라서 점화식을 우선 세우고자 한다. 하지만 이를 위해서는 상황을 관찰해야 한다.

`dp[i][j]`라는 2차원 array를 생각해보고자 한다. 행은 각 아이템이 배정되며, 열의 경우는 무게가 들어간다. 이 때, 0 부터 한계치까지를 모두 고려하려고 한다. 

예시 값을 통해 생각해보려고 한다.

예시) 아이템 4개, 가방 10g,  4g-4 / 8g-5  / 5g-7  / 1g-10   

그러면 다음과 같은 표를 얻을 수 있다.

|       |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |
| ----- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 4g/4  |      |      |      |      |      |      |      |      |      |      |      |
| 8g/5  |      |      |      |      |      |      |      |      |      |      |      |
| 5g/7  |      |      |      |      |      |      |      |      |      |      |      |
| 1g/10 |      |      |      |      |      |      |      |      |      |      |      |

행 별로 채워 나가며, 무게별로 얻을 수 있는 가장 큰 가치의 값을 적는다.

그러면 첫 행은 너무 자연스럽다.



[1행의 결과]

|       |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |
| ----- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 4g/4  |  0   |  0   |  0   |  0   |  4   |  4   |  4   |  4   |  4   |  4   |  4   |
| 8g/5  |      |      |      |      |      |      |      |      |      |      |      |
| 5g/7  |      |      |      |      |      |      |      |      |      |      |      |
| 1g/10 |      |      |      |      |      |      |      |      |      |      |      |



다음은 4g과 8g을 동시에 못 담는다, 그러나 8g의 가치가 5이므로 0~3g은 가치가 0, 4~7g은 가치가 4, 8~10g은 가치가 5가 된다. 이를 표로 적으면 다음과 같다.



[2행의 결과]

|       |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |  10  |
| ----- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 4g/4  |  0   |  0   |  0   |  0   |  4   |  4   |  4   |  4   |  4   |  4   |  4   |
| 8g/5  |  0   |  0   |  0   |  0   |  4   |  4   |  4   |  4   |  5   |  5   |  5   |
| 5g/7  |      |      |      |      |      |      |      |      |      |      |      |
| 1g/10 |      |      |      |      |      |      |      |      |      |      |      |



다음은 정말 잘 생각해야 한다. 

먼저 4g까지는 문제 없다.  

5g일때를 보자, 5g물건을 넣는다면 그냥 그거로 끝이고 4g보다 가치가 높으니 그대로 간다. 이대로 8g까진 그대로 간다. (8g 가치보다 5g의 가치가 더 높다)

그러면 9g일때는 어떨까? 5g 물건을 넣기 전의 가치는 5g,

하지만 5g 물건을 넣으면 4g일때의 최대 가치인 4 + 지금 넣은 거의 가치 7로 총 11의 가치를 얻게 되어, 넣는 것이 이득이다.  10g도 마찬가지이다.

즉, 해당 인덱스에서 가장 높은 가치는 현재 고려하고 있는 아이템을 넣었을 때의 최댓값과 넣지 않았을 때의 최댓값을 비교해야 한다는 것이다.



이런 식으로 생각하여 표를 채워주자.

[3, 4행의 결과]

|       |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9    |   10   |
| ----- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :----: | :----: |
| 4g/4  |   0   |   0   |   0   |   0   |   4   |   4   |   4   |   4   |   4   |   4    |   4    |
| 8g/5  |   0   |   0   |   0   |   0   |   4   |   4   |   4   |   4   |   5   |   5    |   5    |
| 5g/7  | **0** | **0** | **0** | **0** | **4** | **7** | **7** | **7** | **7** | **11** | **11** |
| 1g/10 |   0   |  10   |  10   |  10   |  10   |  14   |  17   |  17   |  17   |   17   | **21** |

21 이라는 답을 얻을 수 있다. (이 정도는 실제로 손으로 계산해도 맞았음을 알 수 있다.)



그러면 위의 과정을 점화식으로 표현하려고 한다.



#### 2단계. 식 수립

위의 표의 각 칸을 `dp[i][j]`라고 하자.

이거는 다음과 같이 구할 수 있다.

- 무게가 j일때, i번째 아이템을 챙기지 않았을때의 최댓값
- 무게가 j일때, i번째 아이템을 챙기고 남은 무게로 얻을 수 있는 가치의 최댓값

따라서

`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i])`

이렇게 세울 수 있다.



#### 3단계. 코드 작성

위의 식 대로 코드를 작성하면 된다. 단 첫줄은 뭐가 있어야 저 작업이 될거니. 초항만 별도로 작성하면 끝.!

```python
# knapsack algorithm

items, weight_lim = map(int, input().split())
weight = [0] * items
value = [0] * items
for i in range(0, items):
    weight[i], value[i] = map(int, input().split())

dp = [[0] * (weight_lim+1) for _ in range(0, items)]

for i in range(0, items):
    if i == 0:  # 첫 줄 작성
        if weight[0] <= weight_lim:
            for j in range(weight[0], weight_lim+1):
                dp[0][j] = value[0]
    else:  # 이 뒤부터는 점화식을 작성함. 넘어가면 그냥 안 넣으면 됨
        for j in range(0, weight_lim+1):
            if j-weight[i] >= 0:
                dp[i][j] = max(dp[i-1][j],
                               dp[i-1][j-weight[i]]+value[i])
            else:
                dp[i][j] = dp[i-1][j]

print(dp[-1][-1])
```

**무게를 단순히 그 g만 따지는 것이 아닌, 0g부터 전부 다 해볼 생각은 하지 못했기에, 답을 찾지 못했던 것 같다.** 